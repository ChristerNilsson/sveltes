var app=function(){"use strict";function t(){}function e(t){return t()}function n(){return Object.create(null)}function r(t){t.forEach(e)}function s(t){return"function"==typeof t}function i(t,e){return t!=t?e==e:t!==e||t&&"object"==typeof t||"function"==typeof t}let o;function a(t){o=t}const c=[],u=[],l=[],d=[],p=Promise.resolve();let f=!1;function h(t){l.push(t)}function $(){const t=new Set;do{for(;c.length;){const t=c.shift();a(t),b(t.$$)}for(;u.length;)u.pop()();for(let e=0;e<l.length;e+=1){const n=l[e];t.has(n)||(n(),t.add(n))}l.length=0}while(c.length);for(;d.length;)d.pop()();f=!1}function b(t){t.fragment&&(t.update(t.dirty),r(t.before_update),t.fragment.p(t.dirty,t.ctx),t.dirty=null,t.after_update.forEach(h))}const g=new Set;let m;function y(t,e){t&&t.i&&(g.delete(t),t.i(e))}function D(t,n,i){const{fragment:o,on_mount:a,on_destroy:c,after_update:u}=t.$$;o.m(n,i),h(()=>{const n=a.map(e).filter(s);c?c.push(...n):r(n),t.$$.on_mount=[]}),u.forEach(h)}function k(t,e){t.$$.fragment&&(r(t.$$.on_destroy),t.$$.fragment.d(e),t.$$.on_destroy=t.$$.fragment=null,t.$$.ctx={})}function O(t,e){t.$$.dirty||(c.push(t),f||(f=!0,p.then($)),t.$$.dirty=n()),t.$$.dirty[e]=!0}function V(e,s,i,c,u,l){const d=o;a(e);const p=s.props||{},f=e.$$={fragment:null,ctx:null,props:l,update:t,not_equal:u,bound:n(),on_mount:[],on_destroy:[],before_update:[],after_update:[],context:new Map(d?d.$$.context:[]),callbacks:n(),dirty:null};let h=!1;var b;f.ctx=i?i(e,p,(t,n,r=n)=>(f.ctx&&u(f.ctx[t],f.ctx[t]=r)&&(f.bound[t]&&f.bound[t](r),h&&O(e,t)),n)):p,f.update(),h=!0,r(f.before_update),f.fragment=c(f.ctx),s.target&&(s.hydrate?f.fragment.l((b=s.target,Array.from(b.childNodes))):f.fragment.c(),s.intro&&y(e.$$.fragment),D(e,s.target,s.anchor),$()),a(d)}class x{$destroy(){k(this,1),this.$destroy=t}$on(t,e){const n=this.$$.callbacks[t]||(this.$$.callbacks[t]=[]);return n.push(e),()=>{const t=n.indexOf(e);-1!==t&&n.splice(t,1)}}$set(){}}function N(e){return{c:t,m:t,p:t,i:t,o:t,d:t}}function _(t,e,n){let{script:r,reducers:s,stack:i}=e;const o=chai.assert.deepEqual,a=CodeMirror(document.body,{lineNumbers:!0,tabSize:2,indentWithTabs:!0,theme:"dracula"});a.setValue(r.trim()),a.on("change",()=>{c.setValue(u.run(a.getValue()).join("\n"))});const c=CodeMirror(document.body,{readOnly:!0,tabSize:2}),u=((t,e)=>{let n=[],r=[];const s=(t,s)=>{const o=a(t);if(t=t.trim(),0===o)return n=[JSON.parse(t)];e.length=0;let c=n[o-1];for(const e of t.split(" "))c=i(e,c,s);for(n[o]=c;e.length>=2;)i("==",c,s);1!==e.length||r.push(`Orphan in line ${s+1}`)},i=(n,s,i)=>{if("@"===n)return e.push(s),s;const a=n.slice(1);if(Object.keys(s).includes(a))return e.push(s[a]),s;if(Object.keys(t).includes(n))return t[n](s);if("=="===n){let t,n;try{t=e.pop(),n=e.pop(),o(t,n)}catch(e){r.push("Assert failure in line "+(i+1)),r.push("  Actual "+JSON.stringify(n)),r.push("  Expect "+JSON.stringify(t))}return s}try{if(""==n)return s;e.push(JSON.parse(n))}catch(t){r.push("JSON.parse failure in line "+(i+1)+" "+n),r.push("\t"+n)}return s},a=t=>{let e=0;for(let n=0;n<t.length;n++){if("\t"!==t[n])return e;e++}return e};return{run:t=>{const e=t.split("\n");r=[];for(let t=0;t<e.length;t++){let n=e[t];const i=n.lastIndexOf("#");i>=0&&(n=n.slice(0,i));try{0!=n.trim().length&&s(n,t)}catch(t){r.push(t);break}}return r}}})(s,i);c.setValue(u.run(a.getValue()).join("\n"));const l=()=>{a.setSize(innerWidth,.75*innerHeight),c.setSize(innerWidth,.25*innerHeight)};return l(),window.addEventListener("resize",l),t.$set=(t=>{"script"in t&&n("script",r=t.script),"reducers"in t&&n("reducers",s=t.reducers),"stack"in t&&n("stack",i=t.stack)}),{script:r,reducers:s,stack:i}}class I extends x{constructor(t){super(),V(this,t,_,N,i,["script","reducers","stack"])}}function S(e){var n,r=new I({props:{stack:e.stack,script:e.script,reducers:e.reducers}});return{c(){r.$$.fragment.c()},m(t,e){D(r,t,e),n=!0},p:t,i(t){n||(y(r.$$.fragment,t),n=!0)},o(t){!function(t,e,n,r){if(t&&t.o){if(g.has(t))return;g.add(t),m.c.push(()=>{g.delete(t),r&&(n&&t.d(1),r())}),t.o(e)}}(r.$$.fragment,t),n=!1},d(t){k(r,t)}}}function A(t){const e=[],n=(t,e)=>{if(Math.round(e)!=e)return t;const n=[...t.hist,t.a];return{...t,a:e,hist:n}},r={ADD:t=>n(t,t.a+2),MUL:t=>n(t,2*t.a),DIV:t=>n(t,t.a/2),NEW:t=>({b:e.pop(),a:e.pop(),hist:[]}),UNDO:t=>{const e=t.hist.slice();return{a:e.pop(),b:t.b,hist:e}}};return{stack:e,reducers:r,script:'\n{"a":18,"b":17,"hist":[]}                            # initial state\n\t@ {"a":18,"b":17,"hist":[]} ==                     # assert deep state\n\t@a 18                                              # implicit assert @a == 18\n\tADD @a 20                                          # based on line 1\n\tMUL @a 36 @hist [18]                               # also based on line 1\n\tDIV @ {"a":9,"b":17,"hist":[18]}                   # @ is the state\n\t\tDIV @ {"a":9,"b":17,"hist":[18]}                 # DIV odd is not possible\n\t3 4 NEW @a 3 @b 4 @hist []                         # NEW takes two parameters\n{"a":17,"b":1,"hist":[]}                             # another initial state\n\tMUL ADD DIV @ {"a":18,"b":1,"hist":[17,34,36]}     # based on line 9\n\t\tUNDO @ {"a":36,"b":1,"hist":[17,34]}             # based on line 10\n\t\t\tUNDO @ {"a":34,"b":1,"hist":[17]}              # based on line 11\n\t\t\t\tUNDO @ {"a":17,"b":1,"hist":[]}              # based on line 12\n\tMUL ADD DIV ADD DIV ADD DIV ADD DIV DIV DIV @a @b  # from 17 to 1 in 11 steps\n'}}return new class extends x{constructor(t){super(),V(this,t,A,S,i,[])}}({target:document.body,props:{}})}();
//# sourceMappingURL=bundle.js.map
